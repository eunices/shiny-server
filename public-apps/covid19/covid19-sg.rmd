---
runtime: shiny
title: "COVID 19 Singapore"
output: 
  html_document:
    toc: true
    theme: flatly
---

```{r echo=FALSE}
knitr::opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE)
```

```{r}
# Libraries
library(rvest)
library(ggplot2)
library(tidyr)
library(data.table)
library(gridExtra)
source('main.r')
source('util.r')

# Resources
# https://staff.math.su.se/hoehle/blog/2020/03/16/flatteningthecurve.html
# https://blog.ephorie.de/covid-19-the-case-of-germany 
# https://rviews.rstudio.com/2020/03/19/simulating-covid-19-interventions-with-r/

# Params
theme = theme_minimal()
```

## Get data

```{r}
url = "https://co.vid19.sg/cases/search"
df = try({get_data(url)})
if(!grepl("error", df[[1]])) {
  df = clean_data(df)
} else {
  df = get_alternative_data()
}  
```

Data is obtained from `r url` (which appears to be defunct as of 2 Apr 2020, and I started collected data on my own). 

Clusters information were obtained from this [Straits Times news article](https://www.straitstimes.com/singapore/health/novel-coronavirus-cases-in-singapore).

```{r echo=TRUE}
str(df)
```

Notes about data: 

1. symptomatic < confirmed < recovered date
2. `days.to.recover.symptomatic` = recovered - symptomatic
3. `days.to.recover.resources` = recovered - confirmed

The data differs slightly from the MOH's press releases annex:

1. Does not have hospital information
2. Does not have case local linked/unlinked
3. Does not have cluster information or links (for non-cluster cases). Both are considered "local linked".
4. Only one imported country, when there could be a list.
5. Does not have "long-term pass" information, due to data cleaning issues prior to 1 Apr 2020. 
6. Citizen and PR are same, i.e. "citizen".
7. Local linked cases may also be imported or have a travel history. But the former takes precedence. (e.g. case 973 linked to Lee Ah Mooi Home).


## What are the figures

### Coronavirus through time

#### Cases detected through time
```{r}
min_date = min(df$confirmed.at.date, na.rm=T)
max_date = max(df$confirmed.at.date, na.rm=T)
date_second_wave = as.Date("2020-02-25")
```

The first case detected in Singapore on `r format(min_date, "%d %B %Y")`. 

```{r}
style = "display: inline-block;vertical-align:top;padding-right: 20px"
bootstrapPage(
  div(style=style, dateRangeInput("range_date", "Date range", 
                                  start = min_date, end = max_date,
                                  min = min_date, max = max_date)),
  div(style=style, numericInput("binwidth_date", "Days bin width", value = 1, min=1, max=14)))

renderPlot({
    # input = list(range_date = c(as.Date(min_date), as.Date(max_date)), binwidth=1) # test
    min_date = input$range_date[1]
    max_date = input$range_date[2]
    data = df[df$confirmed.at.date >= min_date & df$confirmed.at.date <= max_date,]

    ggplot(data=data, aes(x=confirmed.at.date)) +
      geom_histogram(stat="bin", binwidth=input$binwidth_date, fill="steelblue") + 
      xlab("") + ylab("") + 
      geom_vline(xintercept=date_second_wave, size=2, col="red") +
      annotate("text", x=date_second_wave, y=20, label= "Second wave") + 
      scale_x_date(date_breaks = "weeks", date_labels = "%Y EW %U") +
      theme
}, height=280)

renderPlot({
    min_date = input$range_date[1]
    max_date = input$range_date[2]
    data = df[df$confirmed.at.date >= min_date & df$confirmed.at.date <= max_date,]

    type_label = c("imported case", "local transmission")
    names(type_label) = c("Imported", "Local")

    ggplot(data=data, aes(x=confirmed.at.date, fill=infection.source)) +
      geom_histogram(stat="bin", binwidth=input$binwidth_date) + 
      facet_wrap(~ infection.source, ncol=1, labeller = camelcase_labeller) + 
      geom_vline(xintercept=date_second_wave, size=2, col="red") +
      annotate("text", x=date_second_wave, y=20, label= "Second wave") + 
      scale_fill_discrete(name="Case type", breaks=type_label, labels=names(type_label)) + 
      xlab("") + ylab("Number of confirmed cases detected\n") +
      scale_x_date(date_breaks = "weeks", date_labels = "%Y EW %U") +
      theme
})
```

From here, we can see that there are two waves of imported cases, the first from EW 03 to EW 07 and second from EW 08 onwards. These are associated with the Chinese cases mainly and when there was a global spread subsequently with Europe as the epicenter.

### Key measures

This records the key measures the Singapore government has taken.

- 2020-04-02: work from home mandated, [offense otherwise](https://www.channelnewsasia.com/news/singapore/covid-19-work-from-home-singapore-jail-fines-coronavirus-1260222).
- 2020-03-28: defer non-essential trips to malls
- 2020-03-27: [home based learning](http://go.gov.sg/homebasedlearning) once a week for primary, secondary schools, and junior college
- 2020-03-26: spacing regulated in malls/ supermarket, e.g. 1 m distance (marked by duct tapes)
- 2020-03-25: large-scale events (>250 people) suspended till 30 Jun
- 2020-03-24: many gatherings suspended till 30 Apr. 
- 2020-03-22: [no short-term visitors allowed, workpass only essential services](http://go.gov.sg/travel22mar).
- 2020-03-20: [ActiveSG sport centres social distancing measures](http://go.gov.sg/sport15mar).
- 2020-03-18: [Malaysia under lock down](http://go.gov.sg/mco) till 14 Apr; increased border control measures.
- 2020-03-16: [Singaporeans to defer all non-essential travel](http://go.gov.sg/travel-15mar); [temporary closure of mosques](https://www.muis.gov.sg/Media/Media-Releases/16-Mar-20-Media-Statement-on-Extension-of-Temporary-Closure-of-Mosques).
- 2020-03-14: encourage employers to allow [tele-commuting/ staggered work hours](http://go.gov.sg/workplacesocialdistancing).
- 2020-03-13: [large-scale ticketed events with >250 people to be deferred/cancelled](http://go.gov.sg/socialdistancing-13mar).
- 2020-03-11: [senior activities suspended, till 24 March - was later extended on 25 Mar](http://go.gov.sg/PAseniors).
- 2020-03-10: Port call by [Costa Fortuna](http://go.gov.sg/mpa9mar).
- 2020-03-04: [work pass holders allowed to return, be swabbed with 5-6 hours turnaround for test results](http://go.gov.sg/mom3mar).
- 2020-02-28: [schools with extra precaution](http://go.gov.sg/covid19-MOE).
- 2020-02-23: [start of travel advisories to outbreak countries other than China (e.g. Daegu, Korea)](http://go.gov.sg/mom-27feb).
- 2020-02-19: [introduction of Stay Home Notice](http://go.gov.sg/StayHomeNotice).
- 2020-02-07: [some community spread in Singapore, DORSCON orange. Business continuity plans kick in and temp. screening](http://go.gov.sg/dorscon7feb).

Source: https://www.moh.gov.sg/news-highlights/

```{r fig.height=6, fig.width=9}
data_1st_wave = data.table(df[df$confirmed.at.date < date_second_wave & df$infection.source == "imported case",])
data_1st_wave = data_1st_wave[, list(N=length(case)), by="country.of.origin"]

data_2nd_wave = data.table(df[df$confirmed.at.date >= date_second_wave & df$infection.source == "imported case",])
data_2nd_wave = data_2nd_wave[, list(N=length(case)), by="country.of.origin"]

grid.arrange(
  ggplot(data_1st_wave, aes(x=reorder(camelcase_labeller("", country.of.origin), -N), y=N)) +
  geom_bar(stat = "identity") + coord_flip() + theme_minimal() +
  xlab("") + ylab("") + ggtitle("First wave") +
  theme(axis.text.x=element_text(size=rel(0.5), angle=90)),
  
  ggplot(data_2nd_wave, aes(x=reorder(camelcase_labeller("", country.of.origin), -N), y=N)) +
  geom_bar(stat = "identity") + coord_flip() + theme_minimal() +
  xlab("") + ylab("Number of imported cases detected") + ggtitle("Second wave") +
  theme(axis.text.y=element_text(size=rel(0.7)))
)
```

```{r}
# SIR 
```

TODO: SIR model

#### Cluster characteristics

TODO:
- duration of cluster
- type of venue of cluster
- number of people involved

#### Test kits

TODO:
- estimate test kit availability

#### Hospital load

```{r} 
max_load = 9*1200*0.15 # hospital capacity
hosp_prop = 0.2        # proportion of cases requiring hospitalisation
date_no_hosp = as.Date("2020-03-24") # date when hospitalisation not required for positive, asymptomatic cases
```

Case load is an important metric that is correlated also with hospital load. Here, it's the sum of people who are not recovered. 

```{r}
df_cases = df[df$status != "Deceased", c("case", "symptomatic.at.date", "recovered.at.date", "confirmed.at.date")]
df_cases[is.na(df_cases$recovered.at.date),]$recovered.at.date = Sys.Date()
df_cases[is.na(df_cases$symptomatic.at.date),]$symptomatic.at.date = 
  df_cases[is.na(df_cases$symptomatic.at.date),]$confirmed.at.date # use confirmed.at if no symptomatic

df_cases$day = mapply(function(min, max) { seq(min, max, by="day") }, 
                       min=df_cases$symptomatic.at.date, max=df_cases$recovered.at.date)
df_cases_day = data.table(unnest(df_cases, cols=c(day, case))); rm(df_cases)
df_cases_day = df_cases_day[, list(case_load=length(case)), by="day"]
df_cases_day$case_load = as.numeric(df_cases_day$case_load)
df_cases_day$hospital_load = df_cases_day$case_load
df_cases_day[day>=date_no_hosp,]$hospital_load =  
  df_cases_day[day>=date_no_hosp,]$hospital_load * hosp_prop
```


```{r}
renderPlot({
  ggplot(data=df_cases_day, aes(x=day, y=case_load)) +
    geom_bar(stat="identity", fill="steelblue") + 
    xlab("") + ylab("Number of cases\n") + 
    scale_x_date(date_breaks = "weeks" , date_labels = "%Y EW %U") +
    theme
})
```

Measuring hospital load is key to ensure that hospitals are not overloaded.  We assume that the number of those who require hospitalisation is 20% of the case load, since it is a conservative estimate that 20% of the patients require hospitalisation and/or ICU care. From [24 Mar 2020](https://go.gov.sg/measures24mar), those who still test positive but display no symptoms will no longer be hospitalised. 

```{r}
renderPlot({
  ggplot(data=df_cases_day, aes(x=day, y=hospital_load)) +
    geom_bar(stat="identity", fill="steelblue") + 
    geom_vline(xintercept=date_no_hosp, size=2, col="red") +
    xlab("") + ylab("Number of (estimated) hospitalised persons\n") + 
    scale_x_date(date_breaks = "weeks" , date_labels = "%Y EW %U") +
    theme
})
```

There are 9 public acute hospitals in Singapore, with an average capacity of 1,200 beds. They are currently operating at approximately [75% load](https://www.moh.gov.sg/resources-statistics/healthcare-institution-statistics/beds-occupancy-rate-(bor)). We assume that hospitals can operate at a 90% bed load, to ensure that hospitals are not overtaxed and there is sufficient isolation between covid patients (more than usual required). Then there would be `r max_load` beds available. 


```{r}
renderPlot({
  ggplot(data=df_cases_day, aes(x=day, y=round(hospital_load/max_load*100, 2))) +
    geom_bar(stat="identity", fill="steelblue") + 
    geom_vline(xintercept=date_no_hosp, size=2, col="red") +
    xlab("") + ylab("% of (estimated) maximum patient load\n") + 
    scale_x_date(date_breaks = "weeks" , date_labels = "%Y EW %U") +
    theme
}, height=280)
```

### Recovery time

Recovered date is based on the discharged date when there are [consecutive negative PCR tests](https://www.channelnewsasia.com/news/singapore/).

#### Days to recovery histogram

```{r}
is.recovered = table(!is.na(df[, c("days.to.recover.symptomatic")]))
```
- Number of recovered persons: 
  `r is.recovered[2]`
- Proportion of recovered persons: 
  `r round(prop.table(is.recovered)[2]*100, 1)`%

- Median time to recovery (from confirmed): 
  `r as.numeric(median(df[, c("days.to.recover.symptomatic")], na.rm=T))` days
- Median time to recovery (from confirmed): 
  `r round(as.numeric(mean(df[, c("days.to.recover.symptomatic")], na.rm=T)), 1)` days

```{r fig.height=3, fig.width=5}
binwidth = 5
min = as.numeric(min(df[, c("days.to.recover.symptomatic")], na.rm=T))
max = as.numeric(max(df[, c("days.to.recover.symptomatic")], na.rm=T))
hist_max = max(table(cut(as.numeric(df[, c("days.to.recover.symptomatic")]), 
                         breaks=seq(min, max, by=binwidth), right = FALSE)))

ggplot(df, aes(x=days.to.recover.symptomatic)) + 
  geom_histogram(binwidth=binwidth, na.rm=T) + 
  xlab("Days to recover") + ylab("Number of people") +
  scale_y_continuous(breaks=seq(0, hist_max, ifelse(hist_max<30, 1, 5))) +
  scale_x_continuous(breaks=seq(0, max, ifelse(max<30, 1, 5))) + 
  theme
```

### Deaths

```{r}
# TODO: deceased at date
deceased = df[df$status == "Deceased", c("case", "age", "gender", "patient.nationality",
                                         "confirmed.at.date", "infection.source")]
knitr::kable(deceased, "markdown")
```

Number of deceased: `r dim(deceased)[1]`

### Risk factors

#### Age

Here we attempt to investigate if there is an association with number of days to recover and age, as [fatalities are higher for elderly above 65](https://www.businessinsider.sg/most-us-coronavirus-deaths-ages-65-older-cdc-report-2020-3).

```{r}
selectInput("age_width", label = "Age bin width", choices = c(5, 10, 20), selected = 5)
renderPlot({
  # input = list(age_width=10)
  agewidth = as.numeric(input$age_width)
  min = as.numeric(min(df$age, na.rm=T))
  max = as.numeric(max(df$age, na.rm=T))
  data = data.frame(cat=cut(as.numeric(df$age), breaks=seq(0, max, by=agewidth), right = FALSE),
                    age=df$age, days=df[, c("days.to.recover.symptomatic")])
  data = data[!is.na(data$cat),]

  ggplot(data, aes(x=cat, y=days)) + 
    geom_boxplot() +
    geom_jitter(height = 0, width = 0.1) +
    xlab("Age category") + ylab("Days to recover") + theme
})
```

#### Gender

```{r}
ggplot(df, aes(x=gender, y=days.to.recover.symptomatic)) +
  geom_boxplot() +
  geom_jitter(height = 0, width = 0.1) +
  xlab("Gender") + ylab("Days to recover") + theme
```


```{r fig.height=4, fig.width=12}
# ggplot(df, aes(x=as.numeric(age), y=as.numeric(days.to.recover.symptomatic))) + 
#   geom_smooth(method='lm', formula= y~x) +
#   geom_point() + 
#   xlab("Age") + ylab("Days to recover") +
#   theme

# # Calculate Rsq
# df_corr = df[!is.na(df[, c("days.to.recover.symptomatic")]),]
# rsq = cor(as.numeric(df_corr$age), as.numeric(df_corr$days.to.recover.symptomatic))^2
```
