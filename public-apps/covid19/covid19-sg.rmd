---
runtime: shiny
title: "COVID 19 Singapore"
output: 
  html_document:
    toc: true
    theme: flatly
---


```{r echo=FALSE}
knitr::opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE)
```

```{r}
# Libraries
library(rvest)
library(ggplot2)
library(tidyr)
library(data.table)
library(gridExtra)
source('main.r')
source('util.r')

# Params
theme = theme_minimal()
```

```{r}
url1 = "https://co.vid19.sg/cases/search"
url2 = "https://www.againstcovid19.com/singapore/cases/search"
# df = try({get_data(url1)})
# if(!grepl("error", df[[1]])) {
#   df = clean_data(df)
# } else {
#   df = get_alternative_data()
# }  

df = get_alternative_data()
```

```{r}
# Columns are deaths [D], critical condition (ICU) [I1], cases in hospital [I2], 
# cases well but still test positive [I3], recovered [R],
# new cases (imported) [nI], new cases (local) [nL], total cases [total]:
# see cases.csv
```

## What are the figures

### Coronavirus through time

#### New cases through time
```{r}
min_date = min(df$confirmed.at.date, na.rm=T)
max_date = max(df$confirmed.at.date, na.rm=T)
date_second_wave = as.Date("2020-02-25")
```

The first case detected in Singapore on `r format(min_date, "%d %B %Y")`. 

```{r}
style = "display: inline-block;vertical-align:top;padding-right: 20px"
bootstrapPage(
  div(style=style, dateRangeInput("range_date", "Date range", 
                                  start = min_date, end = max_date,
                                  min = min_date, max = max_date)),
  div(style=style, numericInput("binwidth_date", "Days bin width", value = 1, min=1, max=14)))

renderPlot({
    # input = list(range_date = c(as.Date(min_date), as.Date(max_date)), binwidth=1) # test
    min_date = input$range_date[1]
    max_date = input$range_date[2]
    data = df[df$confirmed.at.date >= min_date & df$confirmed.at.date <= max_date,]

    ggplot(data=data, aes(x=confirmed.at.date)) +
      geom_histogram(stat="bin", binwidth=input$binwidth_date, fill="steelblue") + 
      xlab("") + ylab("") + 
      geom_vline(xintercept=date_second_wave, size=2, col="red") +
      annotate("text", x=date_second_wave, y=20, label= "Second wave") + 
      scale_x_date(date_breaks = "weeks", date_labels = "%Y EW %U") +
      theme
}, height=280)

renderPlot({
    min_date = input$range_date[1]
    max_date = input$range_date[2]
    data = df[df$confirmed.at.date >= min_date & df$confirmed.at.date <= max_date,]

    type_label = c("Imported case", "Local transmission")
    names(type_label) = c("Imported", "Local")

    ggplot(data=data, aes(x=confirmed.at.date, fill=infection.source)) +
      geom_histogram(stat="bin", binwidth=input$binwidth_date) + 
      facet_wrap(~ infection.source, ncol=1, labeller = camelcase_labeller) + 
      geom_vline(xintercept=date_second_wave, size=2, col="red") +
      annotate("text", x=date_second_wave, y=20, label= "Second wave") + 
      scale_fill_discrete(name="Case type", breaks=type_label, labels=names(type_label)) + 
      xlab("") + ylab("Number of confirmed cases detected\n") +
      scale_x_date(date_breaks = "weeks", date_labels = "%Y EW %U") +
      guides(fill=F) +
      theme
})

renderPlot({
    min_date = input$range_date[1]
    max_date = input$range_date[2]
    data = df[df$confirmed.at.date >= min_date & df$confirmed.at.date <= max_date,]
    data = data[data$infection.source == "Local transmission",]
    data$clustered = ifelse(data$cluster == "", "Not in cluster", "Cluster case")
    cluster = data[data$clustered=="Cluster case",]
    cluster = data[!duplicated(data$cluster),]

    p1 = ggplot(data=cluster, aes(x=confirmed.at.date)) +
      geom_histogram(stat="bin", binwidth=input$binwidth_date) + 
      xlab("") + ylab("Number of clusters detected\n") +
      scale_x_date(date_breaks = "weeks", date_labels = "%Y EW %U") +
      theme

      p2 = ggplot(data=data[data$cluster=="",], aes(x=confirmed.at.date)) +
      geom_histogram(stat="bin", binwidth=input$binwidth_date) + 
      xlab("") + ylab("Number of locally-transmitted \nunlinked cases\n") +
      scale_x_date(date_breaks = "weeks", date_labels = "%Y EW %U") +
      theme

      grid.arrange(p1, p2)
})

```

#### Two waves

From here, we can see that there are two waves of imported cases, the first from EW 03 to EW 07 and second from EW 08 onwards. These are associated with the Chinese cases mainly and when there was a global spread subsequently with Europe and other countries as the epicenter. 


```{r fig.height=6, fig.width=9}
data_1st_wave = data.table(df[df$confirmed.at.date < date_second_wave & df$infection.source == "Imported case",])
data_1st_wave = data_1st_wave[, list(N=length(case)), by="country.of.origin"]

data_2nd_wave = data.table(df[df$confirmed.at.date >= date_second_wave & df$infection.source == "Imported case",])
data_2nd_wave = data_2nd_wave[, list(N=length(case)), by="country.of.origin"]

grid.arrange(
  ggplot(data_1st_wave, aes(x=reorder(camelcase_labeller("", country.of.origin), -N), y=N)) +
  geom_bar(stat = "identity") + coord_flip() + theme_minimal() +
  xlab("") + ylab("") + ggtitle("First wave") +
  theme(axis.text.x=element_text(size=rel(0.5), angle=90)),
  
  ggplot(data_2nd_wave, aes(x=reorder(camelcase_labeller("", country.of.origin), -N), y=N)) +
  geom_bar(stat = "identity") + coord_flip() + theme_minimal() +
  xlab("") + ylab("Number of imported cases detected") + ggtitle("Second wave") +
  theme(axis.text.y=element_text(size=rel(0.7)))
)
```

#### Key events

```{r}
events_cols = c("date", "short", "type", "related")
events = fread("events.csv")[, ..events_cols]
names(events) = c("Date", "Event", "Type", "Measure related to")
knitr::kable(events, "markdown")
```

The `Measure related to` refers to:

1. Quarantine and isolation events/measures.
2. Border control events/measures to decrease imported cases.
3. Social distancing measures to reduce number of contacts per day.
4. Good hygiene measures to reduce transmission probability of virus.

### Case load

```{r} 
max_load = (9*1200*0.15) + 300 # hospital capacity
hosp_prop = 0.2        # proportion of cases requiring hospitalisation
date_no_hosp = as.Date("2020-03-24") # date when hospitalisation not required for positive, asymptomatic cases
```

Case load is an important metric that is correlated also with hospital load. Here, it's the sum of people who are not recovered. 

```{r}
df_cases = df[df$patient.status != "Deceased", c("case", "symptomatic.at.date", "recovered.at.date", "confirmed.at.date")]
df_cases[is.na(df_cases$recovered.at.date),]$recovered.at.date = Sys.Date()
df_cases[is.na(df_cases$symptomatic.at.date),]$symptomatic.at.date = 
  df_cases[is.na(df_cases$symptomatic.at.date),]$confirmed.at.date # use confirmed.at if no symptomatic

df_cases$day = mapply(function(min, max) { seq(min, max, by="day") }, 
                       min=df_cases$symptomatic.at.date, max=df_cases$recovered.at.date)
df_cases_day = data.table(unnest(df_cases, cols=c(day, case))); rm(df_cases)
df_cases_day = df_cases_day[, list(case_load=length(case)), by="day"]
df_cases_day$case_load = as.numeric(df_cases_day$case_load)
df_cases_day$hospital_load = df_cases_day$case_load
df_cases_day[day>=date_no_hosp,]$hospital_load =  
  df_cases_day[day>=date_no_hosp,]$hospital_load * hosp_prop
```

```{r}
renderPlot({
  ggplot(data=df_cases_day, aes(x=day, y=case_load)) +
    geom_bar(stat="identity", fill="steelblue") + 
    xlab("") + ylab("Number of cases\n") + 
    scale_x_date(date_breaks = "weeks" , date_labels = "%Y EW %U") +
    theme
})
```

Measuring hospital load is key to ensure that hospitals are not overloaded.  We assume that the number of those who require hospitalisation is 20% of the case load, since it is a conservative estimate that 20% of the patients require hospitalisation and/or ICU care. From [24 Mar 2020](https://go.gov.sg/measures24mar), those who still test positive but display no symptoms will no longer be hospitalised. 

```{r}
renderPlot({
  ggplot(data=df_cases_day, aes(x=day, y=hospital_load)) +
    geom_bar(stat="identity", fill="steelblue") + 
    geom_vline(xintercept=date_no_hosp, size=2, col="red") +
    xlab("") + ylab("Number of (estimated) hospitalised persons\n") + 
    scale_x_date(date_breaks = "weeks" , date_labels = "%Y EW %U") +
    theme
})
```

There are 9 public acute hospitals in Singapore, with an average capacity of 1,200 beds. They are currently operating at approximately [75% load](https://www.moh.gov.sg/resources-statistics/healthcare-institution-statistics/beds-occupancy-rate-(bor)). There is also the NCID has approximately 300 beds. If it is assumed that hospitals can operate at a 90% bed load, to ensure that hospitals are not overtaxed and there is sufficient isolation between covid patients (more than usual required), then there would be `r max_load` beds available. 


```{r}
renderPlot({
  ggplot(data=df_cases_day, aes(x=day, y=round(hospital_load/max_load*100, 2))) +
    geom_bar(stat="identity", fill="steelblue") + 
    geom_vline(xintercept=date_no_hosp, size=2, col="red") +
    xlab("") + ylab("% of (estimated) maximum patient load\n") + 
    scale_x_date(date_breaks = "weeks" , date_labels = "%Y EW %U") +
    theme
})
```

### Recovery

Recovered date is based on the discharged date when there are [consecutive negative PCR tests](https://www.channelnewsasia.com/news/singapore/).

#### Duration of recovery

```{r}
is.recovered = table(!is.na(df[, c("days.to.recover.symptomatic")]))
```
- Number of recovered persons: 
  `r is.recovered[2]`
- Proportion of recovered persons: 
  `r round(prop.table(is.recovered)[2]*100, 1)`%

- Median time to recovery (from confirmed): 
  `r as.numeric(median(df$days.to.recover.symptomatic, na.rm=T))` days
- Mean time to recovery (from confirmed): 
  `r round(as.numeric(mean(df$days.to.recover.symptomatic, na.rm=T)), 1)` days

```{r fig.height=3, fig.width=5}
binwidth = 5
min = as.numeric(min(df$days.to.recover.symptomatic, na.rm=T))
max = as.numeric(max(df$days.to.recover.symptomatic, na.rm=T))
hist_max = max(table(cut(as.numeric(df$days.to.recover.symptomatic), 
                         breaks=seq(min, max, by=binwidth), right = FALSE)))

ggplot(df, aes(x=days.to.recover.symptomatic)) + 
  geom_histogram(binwidth=binwidth, na.rm=T) + 
  xlab("Days to recover") + ylab("Number of people") +
  scale_y_continuous(breaks=seq(0, hist_max, ifelse(hist_max<30, 1, 5))) +
  scale_x_continuous(breaks=seq(0, max, ifelse(max<30, 1, 5))) + 
  theme
```

#### Risk factors

##### Age

Is there an association between number of days to recover and age?

```{r}
selectInput("age_width", label = "Age bin width", choices = c(5, 10, 20), selected = 10)
renderPlot({
  # input = list(age_width=10)
  agewidth = as.numeric(input$age_width)
  min = as.numeric(min(df$age, na.rm=T))
  max = as.numeric(max(df$age, na.rm=T))
  data = data.frame(cat=cut(as.numeric(df$age), breaks=seq(0, max, by=agewidth), right = FALSE),
                    age=df$age, days=df$days.to.recover.symptomatic)
  data = data[!is.na(data$cat),]

  ggplot(data, aes(x=cat, y=days)) + 
    geom_boxplot() +
    geom_jitter(height = 0, width = 0.1) +
    xlab("Age category") + ylab("Days to recover") + theme
})
```

##### Gender

```{r}
ggplot(df, aes(x=gender, y=days.to.recover.symptomatic)) +
  geom_boxplot() +
  geom_jitter(height = 0, width = 0.1) +
  xlab("Gender") + ylab("Days to recover") + theme
```

```{r fig.height=4, fig.width=12}
# ggplot(df, aes(x=as.numeric(age), y=as.numeric(days.to.recover.symptomatic))) + 
#   geom_smooth(method='lm', formula= y~x) +
#   geom_point() + 
#   xlab("Age") + ylab("Days to recover") +
#   theme

# # Calculate Rsq
# df_corr = df[!is.na(df[, c("days.to.recover.symptomatic")]),]
# rsq = cor(as.numeric(df_corr$age), as.numeric(df_corr$days.to.recover.symptomatic))^2
```

### Deaths

```{r}
cols = c("age", "gender", "patient.nationality", "patient.citizen",
         "confirmed.at.date", "infection.source", "deceased.at.date")
deceased = df[df$patient.status == "Deceased", ..cols]
names(deceased) = unlist(lapply(gsub("\\.", " ", cols), function(x) camelcase_labeller("", x)))
```

[Fatalities are higher for elderly above 65](https://www.businessinsider.sg/most-us-coronavirus-deaths-ages-65-older-cdc-report-2020-3). 

Number of deceased: `r dim(deceased)[1]`

```{r}
knitr::kable(deceased, "markdown")
```

### Clusters

TODO:duration of cluster, type of venue of cluster, number of people involved


## Methods

### Data aquisition

**Prior to 1 Apr 2020**, data was obtained from `r url1` up till 1 Apr 2020. The site became defunct from 2 Apr 2020 onwards though later it was found that they migrated to `r url2`. 

**From 2 Apr 2020**, data was collected based on the [MOH press releases annexes](https://www.moh.gov.sg/news-highlights). 

In addition, the following was done to the dataset collected from `r url1`:

1. Prior data was augmented from this [Straits Times news article](https://www.straitstimes.com/singapore/health/novel-coronavirus-cases-in-singapore) retrospectively with information on clusters and links which were omitted from `r url1`.
2. The MOH annex format was adopted, as it was more comprehensive (more variables) wher certain fields, e.g. links, cluster and hospital were missing prior to that. 
3. The citizenship column was changed to country names. 
4. Columns which were already captured in other columns (from `r url1`) were removed because they could result in conflicting columns.
5. Add a `deceased.at.date` column.

There are some differences between the dataset from `r url1` as compared to the MOH annexes:

1. Does not have hospital information.
2. Does not have cluster information or links (for non-cluster cases).
3. One imported country which is derived from the travel history field in the MOH annex. Where there are multiple countries, it is labelled as "unclear origin". 
4. Long term pass and work pass status seem to be inaccurately captured.

The specific steps taken to get the data: 

1. Adding to daily summary statistics, captured in `cases.csv`.
2. Adding to the case-level dataset, captured in `9999-01-01-data.csv`.
    a. Adding MOH annexes data to the main list of documents. 
    b. Adding `recovered.at.date` if cases have recovered.
    c. Adding new links and clusters to existing cases as contact tracing has made progress.

### Notes about data

1. `symptomatic` < `confirmed` < `recovered` dates.
2. `days.to.recover.symptomatic` = recovered - symptomatic.
3. `days.to.recover.resources` = recovered - confirmed.
4. `hospital` is the hospital warded (may have been transferred from another hospital).
5. `links.to` are linked cases which are not family; `links.to.family` are linked cases which are family.
6. No detailed annexes from 5-6 Apr 2020, only cluster links and release dates updated.
7. The `confirmed.at.date` is press release date, not the `confirmed at date` provided by MOH Annex for dataset collected from 2 Apr 2020, whereas it was otherwise so prior to 2 Apr 2020.

